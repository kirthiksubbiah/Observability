# Observability Essentials for SREs

This guide provides a comprehensive overview of observability concepts and tools required for onboarding applications into an SRE-managed platform.

## 1. What is Observability?

Observability is the ability to understand the internal state of a system based on its external outputs, such as metrics, logs, and traces.

Analogy: Just like a car dashboard provides insight into the engine without opening it, observability tools help monitor applications without directly accessing their internal processes.

## 2. Metrics

**Definition**: Numeric data points collected over time that indicate the performance and health of a system.

**Use Cases**:
- Monitoring system resource usage (CPU, memory)
- Setting alerts based on thresholds
- Defining and tracking SLOs and SLIs

**Examples**:
- CPU usage: 85%
- Request count: 10,000 requests/min
- Error rate: 2% failures

**Common Tools**:
- Prometheus for collection and querying
- Grafana for visualization
- OpenTelemetry for exporting telemetry data

## 3. Logs

**Definition**: Time-stamped records generated by systems or applications to capture events and messages.

**Use Cases**:
- Debugging and identifying issues
- Auditing system activities
- Analyzing trends and user behavior

**Examples**:
- Apache server logs
- Application logs in CSV or JSON format

**Good Logging Practices**:

| Poor Example | Improved Example |
|--------------|------------------|
| Login failed for user 5 | { "event": "login_failed", "user_id": 5, "level": "warn" } |

**Standards**:

- Logs must be directed to a known location (file or stdout)
- Use structured JSON format
- Include log levels: info, warn, error, debug
- Allow dynamic configuration of log levels
- Include contextual fields such as user_id, request_id, environment, region
- Support correlation with traces when possible

## 4. Traces

**Definition**: Traces track the full path of a request as it flows through multiple services and components.

**Use Cases**:
- Identifying bottlenecks in request processing
- Visualizing service interactions and latencies

**Example Trace**:
- GET /product: 0.38s
- GET /authz: 0.09s
- DB query: 0.19s

## 5. Spans vs Traces

| Concept | Description |
|---------|-------------|
| Trace | The complete journey of a request |
| Span | A single unit of work within a trace, such as a function call or database query |

Each span includes timing data and is part of a trace, allowing granular analysis of system behavior.

## 6. Observability Infrastructure

**Logging Infrastructure**:

| Tool          | Function             |
|---------------|----------------------|
| Fluentd       | Collects and routes logs |
| Elasticsearch | Stores and indexes logs |
| Kibana        | Provides search and dashboards for logs |

**Tracing Infrastructure**:

| Tool                  | Function                        |
|-----------------------|---------------------------------|
| OpenTelemetry Collector | Collects all telemetry data    |
| Tempo                 | Stores distributed traces       |
| Grafana               | Visualizes metrics, logs, and traces |

**Data Flow**:
Applications emit data → OpenTelemetry Collector → Tempo (traces), Prometheus (metrics), Loki (logs) → Grafana for visualization

## 7. Why Observability Matters

- Reduces time to identify and fix issues
- Enables proactive alerting and monitoring
- Improves system visibility and resilience
- Supports automation and root cause analysis
- Helps meet SLOs and SLA commitments

## 8. Summary

| Category | Purpose                   | Tools                                 |
|----------|---------------------------|----------------------------------------|
| Metrics  | System health and trends  | Prometheus, Grafana                    |
| Logs     | Detailed event records    | Fluentd, Elasticsearch, Kibana, Loki  |
| Traces   | Request path and latency  | OpenTelemetry, Tempo, Grafana          |
